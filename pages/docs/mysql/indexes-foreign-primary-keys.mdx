### Indexes, foreign keys and composite primary keys

```typescript copy filename="db.ts"
import { foreignKey, index, uniqueIndex, integer, pgTable, serial, varchar } from 'drizzle-orm/pg-core';

export const countries = pgTable('countries', {
    id: serial('id').primaryKey(),
    name: varchar('name', { length: 256 }),
    population: integer('population'),
  }, (countries) => {
    return {
      nameIdx: index('name_idx').on(countries.name), // one column
      namePopulationIdx: index('name_population_idx').on(countries.name, countries.population), // multiple columns
      uniqueIdx: uniqueIndex('unique_idx').on(countries.name), // unique index
    }
  })
);

export const cities = pgTable('cities', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 256 }),
  countryId: integer('country_id').references(() => countries.id), // inline foreign key
  countryName: varchar('country_id'),
}, (cities) => {
  return {
    // explicit foreign key with 1 column
    countryFk: foreignKey({
      columns: [cities.countryId],
      foreignColumns: [countries.id],
    }),
    // explicit foreign key with multiple columns
    countryIdNameFk: foreignKey({
      columns: [cities.countryId, cities.countryName],
      foreignColumns: [countries.id, countries.name],
    },
  }
});

export const cpkTable = pgTable('table', {
  column1: integer('column1').default(10).notNull(),
  column2: integer('column2'),
  column3: integer('column3'),
}, (table) => ({
  cpk: primaryKey(table.column1, table.column2),
}));

// Index declaration reference
index('name')
  .on(table.column1, table.column2, ...)
  .onOnly(table.column1, table.column2, ...)  
  .concurrently()
  .using(sql``) // sql expression
  .asc()
  .desc()
  .nullsFirst()
  .nullsLast()
  .where(sql``) // sql expression
```
