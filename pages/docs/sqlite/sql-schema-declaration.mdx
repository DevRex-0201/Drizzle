# SQL schema declaration

With `drizzle-orm` you declare SQL schema in TypeScript. You can have either one `schema.ts` file with all declarations or you can group them logically in multiple files. We prefer to use single file schema.

## Single schema file example

```plaintext
ðŸ“¦ <project root>
 â”” ðŸ“‚ src
    â”” ðŸ“‚ db
       â”” ðŸ“œschema.ts
```

## Multiple schema files example

```plaintext
ðŸ“¦ <project root>
 â”” ðŸ“‚ src
    â”” ðŸ“‚ db
       â”” ðŸ“‚ schema
          â”œ ðŸ“œusers.ts
          â”œ ðŸ“œcountries.ts
          â”œ ðŸ“œcities.ts
          â”œ ðŸ“œproducts.ts
          â”œ ðŸ“œclients.ts
          â”œ ðŸ“œenums.ts
          â”” ðŸ“œetc.ts
```

This is how you declare SQL schema in `schema.ts`. You can declare tables, indexes and constraints, foreign keys and enums. Please pay attention to `export` keyword, they are mandatory if you'll be using [drizzle-kit SQL migrations generator](./migrations).

```typescript copy
import { sqliteTable, text, integer, uniqueIndex } from 'drizzle-orm/sqlite-core';

export const countries = sqliteTable('countries', {
    id: integer('id').primaryKey(),
    name: text('name'),
  }, (countries) => ({
    nameIdx: uniqueIndex('nameIdx').on(countries.name),
  })
);

export const cities = sqliteTable('cities', {
  id: integer('id').primaryKey(),
  name: text('name'),
  countryId: integer('country_id').references(() => countries.id),
})
```

### Database and table entity types

```typescript copy
import { InferModel, text, integer, sqliteTable } from 'drizzle-orm/sqlite-core';

const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  fullName: text('full_name'),
  phone: text('phone'),
})

export type User = InferModel<typeof users> // return type when queried
export type InsertUser = InferModel<typeof users, 'insert'> // insert type
...
import { drizzle, BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';

const sqlite = new Database('sqlite.db');
const db: BetterSQLite3Database = drizzle(sqlite);

const result: User[] = await db.select(users).all()

const insertUser = (user: InsertUser) => {
  return db.insert(users).values(user).run()
}
```

### The list of all column types. 

You can also create custom types - [see here](./custom-types).

```typescript
integer('...')
integer('...', { mode: 'number' | 'timestamp' | 'bigint' })
real('...')
text('...');
text<'union' | 'string' | 'type'>('...');

blob('...');
blob('...', { mode: 'json' | 'buffer' });
blob<{ foo: string }>('...');

column.primaryKey()
column.notNull()
column.default(...)
```

### Indexes, foreign keys and composite primary keys

```typescript copy
import { sqliteTable, foreignKey, primaryKey, text, integer, index, uniqueIndex } from "drizzle-orm/sqlite-core";

export const countries = sqliteTable('countries', {
    id: integer('id').primaryKey(),
    name: text('name', { length: 256 }),
    population: integer('population'),
  }, (countries) => ({
    nameIdx: index('name_idx').on(countries.name), // one column
    namePopulationIdx: index('name_population_idx').on(countries.name, countries.population), // multiple columns
    uniqueIdx: uniqueIndex('unique_idx').on(countries.name), // unique index
  })
);

export const cities = sqliteTable('cities', {
  id: integer('id').primaryKey(),
  name: text('name', { length: 256 }),
  countryId: integer('country_id').references(() => countries.id), // inline foreign key
  countryName: text('country_id'),
}, (cities) => ({
  // explicit foreign key with 1 column
  countryFk: foreignKey(() => ({
    columns: [cities.countryId],
    foreignColumns: [countries.id],
  })),
  // explicit foreign key with multiple columns
  countryIdNameFk: foreignKey(() => ({
    columns: [cities.countryId, cities.countryName],
    foreignColumns: [countries.id, countries.name],
  })),
}));

const pkExample = sqliteTable('pk_example', {
  id: integer('id'),
  name: text('name').notNull(),
  email: text('email').notNull(),
}, (pkExample) => ({
  // composite primary key on multiple columns
  compositePk: primaryKey(pkExample.id, pkExample.name)
}));

// you can have .where() on indexes
index('name_idx').on(table.column).where(sql``)
```
