# Create Read Update Delete

## Querying, sorting and filtering. 

We also support partial select.

```typescript copy
...
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { and, asc, desc, eq, or } from 'drizzle-orm/expressions'
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';

const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('full_name'),
});

const sqlite = new Database('sqlite.db');
const db = drizzle(sqlite);

db.select().from(users).all();
db.select().from(users).where(eq(users.id, 42)).get();

// you can combine filters with and(...) or or(...)
db.select().from(users).where(and(eq(users.id, 42), eq(users.name, 'Dan'))).all();

db.select().from(users).where(or(eq(users.id, 42), eq(users.id, 1))).all();

// partial select
const result = db
  .select({
    field1: users.id,
    field2: users.name,
  })
  .from(users)
  .all();
const { field1, field2 } = result[0];

// limit offset & order by
db.select().from(users).limit(10).offset(10).all();
db.select().from(users).orderBy(users.name).all();
db.select().from(users).orderBy(desc(users.name)).all();
// you can pass multiple order args
db.select().from(users).orderBy(asc(users.name), desc(users.name)).all();
```

#### Conditionally select fields

```typescript copy
function selectUsers(withName: boolean) {
  return db
    .select({
      id: users.id,
      ...(withName ? { name: users.name } : {}),
    })
    .from(users)
    .all();
}

const users = selectUsers(true);
```

#### WITH clause

```typescript copy
const sq = db.select().from(users).where(eq(users.id, 42)).prepareWithSubquery('sq');
const result = db.with(sq).select().from(sq).all();
```

> **Note**: Keep in mind, that if you need to select raw `sql` in a WITH subquery and reference that field in other queries, you must add an alias to it:

```typescript copy
const sq = db
  .select({
    name: sql<string>`upper(${users.name})`.as('name'),
  })
  .from(users)
  .prepareWithSubquery('sq');

const result = db
  .select({
    name: sq.name,
  })
  .from(sq)
  .all();
```

Otherwise, the field type will become `DrizzleTypeError` and you won't be able to reference it in other queries. If you ignore the type error and still try to reference the field, you will get a runtime error, because we cannot reference that field without an alias.

#### Select from subquery

```typescript copy
const sq = db.select().from(users).where(eq(users.id, 42)).subquery('sq');
db.select().from(sq).all();
```

Subqueries in joins are supported, too:

```typescript copy
db.select().from(users).leftJoin(sq, eq(users.id, sq.id)).all();
```

#### List of all filter operators

```typescript
eq(column, value)
eq(column1, column2)
ne(column, value)
ne(column1, column2)

notEq(column, value)
less(column, value)
lessEq(column, value)

gt(column, value)
gt(column1, column2)
gte(column, value)
gte(column1, column2)
lt(column, value)
lt(column1, column2)
lte(column, value)
lte(column1, column2)

isNull(column)
isNotNull(column)

inArray(column, values[])
inArray(column, sqlSubquery)
notInArray(column, values[])
notInArray(column, sqlSubquery)

exists(sqlSubquery)
notExists(sqlSubquery)

between(column, min, max)
notBetween(column, min, max)

like(column, value)
like(column, value)
ilike(column, value)
notIlike(column, value)

not(sqlExpression)

and(...expressions: Expr[])
or(...expressions: Expr[])
```

## Inserting

```typescript copy
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';

const sqlite = new Database('sqlite.db');
const db = drizzle(sqlite);

const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name'),
  createdAt: integer('created_at', { mode: 'timestamp' }),
});

db.insert(users).values({ name: 'Andrew', createdAt: +new Date() }).run();

// insert multiple users
db.insert(users).values({
      name: 'Andrew',
      createdAt: +new Date(),
    },{
      name: 'Dan',
      createdAt: +new Date(),
    }).run();

// insert with returning
const insertedUser = db.insert(users).values({ name: 'Dan', createdAt: +new Date() }).returning().get()
```

## Update

```typescript copy
db.update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(usersTable.name, 'Dan'))
  .run();
```

## Delete 

```typescript copy
db.delete(users)
  .where(eq(usersTable.name, 'Dan'))
  .run();
```